---
title: Key Distribution using PKC
markup: "mmark"
weight: 5
---

## Key Distribution using PKC

In this section, we will use $$\{X\}S_A$$ to denote the signing of $$X$$ by $$A$$, that is, $$\{X\}S_A = X \; || \; E_{KR_A}(H(X))$$.

-----

### Secret key distribution with confidentiality and authentication

![SKD Confidentiality and Authentication](/docs/figures/skd-confidentiality-and-authentication.png)

1. $$A$$ sends $$E(PU_B, N_1 \; || \; A)$$ to $$B$$, that is, a nonce $$N_1$$ and $$A$$'s identifier, encrypted using $$B$$'s public key.
1. $$B$$ sends $$E(PU_A, N_1 \; || \; N_2)$$ to $$A$$, where $$N_2$$ is a nonce generated by $$B$$. Only $$B$$ could have decrypted the message, so the presence of $$N_1$$ in the message assures $$A$$ that the correspondent is in fact $$B$$.
1. $$A$$ sends $$E(PU_B, N_2)$$ back to $$B$$, to assure $$B$$ that its correspondent is $$A$$.
1. $$A$$ selects a secret key $$K_S$$ and sends $$E(PU_B, E(PR_A, K_S))$$ to $$B$$. The message is encrypted using $$B$$'s public key so that only $$B$$ can read it, and encryption with $$A$$'s private key ensures that only $$A$$ could have sent it.
1. $$B$$ computes $$D(PU_A, D(PR_B, M))$$ to recover the secret key.

We will look two other methods of distributing keys using public key cryptography along with digital signatures.

-----

### X.509 with timestamps

![X509 Timestamps](/docs/figures/x509-timestamps.png)

1. $$A$$ sends $$C_A \; || \; \{T_A \; || \; A \; || \; B\}S_A$$ to $$B$$, where
  - $$C_A$$ is $$A$$'s certificate
  - $$T_A$$ is the timestamp of the message, consisting of one or two dates, an expiration date, and optionally the generation time of the token
  - $$A$$ and $$B$$ are included in the message to identify the sender and intended recipient 
1. $$B$$ obtains $$A$$'s public key from $$C_A$$, as well as checking that $$A$$'s certificate has not expired. $$B$$ verifies the signature, and thus the integrity of the signed information. $$B$$ checks that they are indeed the intended recipient and that the timestamp is *current*.
1. If the message is verified, then $$B$$ sends $$C_B \; || \; \{T_B \; || \; B \; || \; A \; || \; E_{KU_A}[K_{AB}]\}S_B$$ where
  - $$C_B$$ is $$B$$'s certificate
  - $$T_B$$ is the timestamp of the message, consisting of one or two dates, an expiration date, and optionally the generation time of the token
  - $$E_{KU_A}[K_{AB}]$$ is the secret key that $$B$$ wishes to distribute, encrypted using $$A$$'s public key
  - $$B$$ and $$A$$ are included in the message to identify the sender and intended recipient
1. $$A$$ obtains $$B$$'s public key from $$C_B$$, and given that $$B$$'s certificate has not expired, $$A$$ will verify the signature of the message. If $$A$$ is able to verify the integrity of the signed information, and that they $$A$$ is indeed the intended recipient and that the timestamp is *current*, then $$A$$ will use their private key to decrypt $$E_{KU_A}[K_{AB}]$$ to obtain the secret key.

**Note**: in order to use timestamps to guarantee freshness, the source of time must be tamper-proof and both parties must have time sources syncronised.

-----

### X.509 with nonces

![X509 Nonces](/docs/figures/x509-nonce.png)

1. $$A$$ sends $$r_A \; || \; A \; || \; B$$ to $$B$$, where $$r_A$$ is a random nonce generated by $$A$$, used to detect replay attacks and to prevent forgery.
1. $$B$$ checks that itself is the intended recipient, if so, $$B$$ sends $$C_B \; || \; r_B \; || \; \{r_A \; || \; B \; || \; A \; || \; E_{KU_A}[K_{AB}]\}S_B$$ where
  - $$C_B$$ is $$B$$'s certificate
	- $$r_B$$ is a random nonce generated by $$B$$
	- $$E_{KU_A}[K_{AB}]$$ is the symmetrical key between $$A$$ and $$B$$, that $$B$$ wishes to distribute, encrypted using $$A$$'s public key, $$KU_A$$
1. $$A$$ obtains $$B$$'s public key from $$C_B$$, as well as checking that $$B$$'s certificate has not expired. $$A$$ verifies the signature, and thus the integrity of the signed information. If the signature is verified, then $$A$$ decrypts the message using $$A$$'s private key, to obtain the symmetric key $$K_{AB}$$.
1. $$A$$ sends $$C_A \; || \; \{r_B \; || \; A \; || \; B\}S_A$$.
1. $$B$$ in turn obtains $$A$$'s public key from $$C_A$$, as well as checking that $$A$$'s certificate has not expired. $$B$$ verifies the signature, and thus the integrity of the signed information. If the message is verified, and the value sent is indeed the nonce generated by $$B$$, then we have achieved mutual authentication.
