<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="Advanced Encryption Standard"><meta property="og:title" content="Advanced Encryption Standard" />
<meta property="og:description" content="Advanced Encryption Standard (AES) AES is the most-used cipher in the world, which was standardised by NIST in 2000 as a replacement for DES, and ever since it has become the world&#39;s de facto encryption standard. AES processes blocks of 128 bits using a secret key of 128, 192 or 256 bits, with the most common being the 128-bit key as it makes encryption slightly faster and the difference between a 128- and 256-bit security is redundant for most applications." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://comp38411.jtang.dev/docs/conventional-cryptography/advanced-encryption-standard/" />

<title>Advanced Encryption Standard | COMP38411</title>
<link rel="icon" href="/favicon.png" type="image/x-icon">


<link rel="stylesheet" href="/book.min.881e5f617a25d889ee043796f91d24629f299fb09dafd02dfb7e5cda023ef8b8.css" integrity="sha256-iB5fYXol2InuBDeW&#43;R0kYp8pn7Cdr9At&#43;35c2gI&#43;&#43;Lg=">


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.0/dist/katex.min.css" integrity="sha384-BdGj8xC2eZkQaxoQ8nSLefg4AV4/AwB3Fj+8SUSo7pnKP6Eoy18liIKTPn9oBYNG" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.0/dist/katex.min.js" integrity="sha384-JiKN5O8x9Hhs/UE5cT5AAJqieYlOZbGT3CHws/y97o3ty4R7/O5poG9F3JoiOYw1" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.0/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>

  
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-136743321-4"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-136743321-4');
</script>



</head>

<body>
  <input type="checkbox" class="hidden" id="menu-control" />
  <main class="flex container">

    <aside class="book-menu fixed">
      <nav>
<h2 class="book-brand">
  <a href="https://comp38411.jtang.dev/"><span>COMP38411</span>
  </a>
</h2>






    <ul>
<li>
<p><strong>🦆 Big Duck NFT 🦆</strong></p>
<ul>
<li><a href="https://www.bigduck.io/">🦆 Website 🦆</a></li>
<li><a href="https://www.bigduck.io/twitter">🦆 Twitter 🦆</a></li>
<li><a href="https://www.bigduck.io/discord">🦆 Discord 🦆</a></li>
</ul>
</li>
<li>
<p><strong>Introduction</strong></p>
<ul>
<li><a href="/docs/introduction/revision/">Revision</a></li>
<li><a href="/docs/introduction/key-definitions/">Key Definitions</a></li>
<li><a href="/docs/introduction/security-attacks/">Security Attacks</a></li>
<li><a href="/docs/introduction/achieving-security/">Achieving Security</a></li>
<li><a href="/docs/introduction/attack-surfaces/">Attack Surfaces</a></li>
<li><a href="/docs/introduction/security-models/">Security Models</a></li>
</ul>
</li>
<li>
<p><strong>Introduction to Cryptography</strong></p>
<ul>
<li><a href="/docs/introduction-to-cryptography/symmetric-encryption/">Symmetric Encryption</a></li>
<li><a href="/docs/introduction-to-cryptography/one-time-pad/">One Time Pad</a></li>
<li><a href="/docs/introduction-to-cryptography/transpositions/">Transpositions</a></li>
<li><a href="/docs/introduction-to-cryptography/stream-ciphers/">Stream Ciphers</a></li>
<li><a href="/docs/introduction-to-cryptography/how-secure/">How Secure?</a></li>
<li><a href="/docs/introduction-to-cryptography/cryptanalysis/">Cryptanalysis</a></li>
</ul>
</li>
<li>
<p><strong>Conventional Cryptography</strong></p>
<ul>
<li><a href="/docs/conventional-cryptography/block-ciphers/">Block ciphers</a></li>
<li><a href="/docs/conventional-cryptography/fiestel-schemes/">Feistel schemes</a></li>
<li><a href="/docs/conventional-cryptography/data-encryption-standard/">Data Encryption Standard</a></li>
<li><a href="/docs/conventional-cryptography/advanced-encryption-standard/"class=active>Advanced Encryption Standard</a></li>
<li><a href="/docs/conventional-cryptography/modes-of-operation/">Modes of Operation</a></li>
<li><a href="/docs/conventional-cryptography/encrypting-any-message-in-cbc-mode/">Encrypting with CBC</a></li>
<li><a href="/docs/conventional-cryptography/attacks-on-block-ciphers/">Attacks on Block Ciphers</a></li>
</ul>
</li>
<li>
<p><strong>Public Key Cryptography</strong></p>
<ul>
<li><a href="/docs/public-key-cryptography/applications/">Applications of PKC</a></li>
<li><a href="/docs/public-key-cryptography/properties/">Properties of PKC</a></li>
<li><a href="/docs/public-key-cryptography/rsa-algorithm/">RSA Algorithm</a></li>
<li><a href="/docs/public-key-cryptography/malleability-of-textbook-rsa/">Malleability of Textbook RSA</a></li>
<li><a href="/docs/public-key-cryptography/rsa-for-encryption/">RSA for Encryption</a></li>
<li><a href="/docs/public-key-cryptography/breaking-textbook-rsa-signatures/">Breaking Textbook RSA Signatures</a></li>
<li><a href="/docs/public-key-cryptography/hybrid-cryptosystems/">Hybrid Cryptosystems</a></li>
</ul>
</li>
<li>
<p><strong>MAC and Hash Functions</strong></p>
<ul>
<li><a href="/docs/mac-and-hash-functions/digest-functions/">Digest Functions</a></li>
<li><a href="/docs/mac-and-hash-functions/message-authentication-code/">Message Authentication Code</a></li>
<li><a href="/docs/mac-and-hash-functions/keyed-hashes/">Keyed Hashes</a></li>
<li><a href="/docs/mac-and-hash-functions/hmac/">HMAC</a></li>
<li><a href="/docs/mac-and-hash-functions/authenticated-encryption/">Authenticated Encryption</a></li>
<li><a href="/docs/mac-and-hash-functions/authenticated-ciphers/">Authenticated Ciphers</a></li>
<li><a href="/docs/mac-and-hash-functions/counter-with-cbc/">Counter with CBC Mode</a></li>
<li><a href="/docs/mac-and-hash-functions/galois-counter-mode/">Galois Counter Mode</a></li>
</ul>
</li>
<li>
<p><strong>Digital Signatures</strong></p>
<ul>
<li><a href="/docs/digital-signatures/digital-signature-algorithm/">Digital Signature Algorithm</a></li>
<li><a href="/docs/digital-signatures/dsa-vs-rsa/">Comparison of DSA and RSA</a></li>
</ul>
</li>
<li>
<p><strong>Public Key Infrastructure</strong></p>
<ul>
<li><a href="/docs/public-key-infrastructure/overview-of-pki/">Overview of PKI</a></li>
<li><a href="/docs/public-key-infrastructure/digital-certificates/">Digital Certificates</a></li>
<li><a href="/docs/public-key-infrastructure/x509-certificates/">X.509 Certificates</a></li>
</ul>
</li>
<li>
<p><strong>Key Management</strong></p>
<ul>
<li><a href="/docs/key-management/key-management-issues/">Key Management Issues</a></li>
<li><a href="/docs/key-management/diffie-hellman-protocol/">Diffie-Hellman Protocol</a></li>
<li><a href="/docs/key-management/key-distribution-without-pkc/">Key Distribution without using PKC</a></li>
<li><a href="/docs/key-management/needham-schroeder-protocol/">Needham-Schroeder Protocol</a></li>
<li><a href="/docs/key-management/key-distribution-using-pkc/">Key Distribution using PKC</a></li>
<li><a href="/docs/key-management/comparison-of-key-establishment-protocols/">Comparison of Key Establishment Protocols</a></li>
</ul>
</li>
<li>
<p><strong>Entity Authentication</strong></p>
<ul>
<li><a href="/docs/entity-authentication/entity-authentication/">Entity Authentication</a></li>
<li><a href="/docs/entity-authentication/unix-password-based-authentication/">UNIX Password-Based Authentication</a></li>
<li><a href="/docs/entity-authentication/one-time-passwords/">One Time Passwords</a></li>
<li><a href="/docs/entity-authentication/smart-card-based-authentication/">Smart Card Based Authentication</a></li>
<li><a href="/docs/entity-authentication/x509-certificate-based-authentication/">X.509 Certificate Based Authentication</a></li>
</ul>
</li>
<li>
<p><strong>IP Security</strong></p>
<ul>
<li><a href="/docs/ip-security/tcp-ip-protocol-stack/">TCP / IP Protocol Stack</a></li>
<li><a href="/docs/ip-security/ip-sec/">IPSec</a></li>
<li><a href="/docs/ip-security/virtual-private-networks/">Virtual Private Networks</a></li>
<li><a href="/docs/ip-security/authentication-header/">Authentication Header</a></li>
<li><a href="/docs/ip-security/encapsulating-security-payload/">Encapsulating Security Payload</a></li>
<li><a href="/docs/ip-security/anti-replay/">Anti-Replay</a></li>
<li><a href="/docs/ip-security/combining-security-associations/">Combining Security Associations</a></li>
<li><a href="/docs/ip-security/comparison-of-ip-level-authentication/">Comparison of IP Level Authentication</a></li>
<li><a href="/docs/ip-security/comparison-of-transport-mode-and-tunnel-mode/">Comparison of Transport Mode and Tunnel Mode</a></li>
</ul>
</li>
</ul>





</nav>


<script>
(function() {
  var menu = document.querySelector("aside.book-menu nav");
  addEventListener("beforeunload", function(event) {
    localStorage.setItem("menu.scrollTop", menu.scrollTop);
  });
  menu.scrollTop = localStorage.getItem("menu.scrollTop");
})();
</script>

    </aside>

    <div class="book-page">
      <header class="flex align-center justify-between book-header">
  <label for="menu-control">
    <img src="/svg/menu.svg" alt="Menu" />
  </label>
  <strong>Advanced Encryption Standard</strong>
</header>

      
<article class="markdown">
  <h2 id="donation">🦆 Big Duck NFT</h2>
  <p><strong>10,000 uniquely generated, cute and social ducks with proof of ownership stored on the Polygon blockchain. Minting will be live on Mon 22 Nov, 12PM GMT. Check it out <a href="https://bigduck.io">here</a></strong>.</p>
  <hr><h2 id="advanced-encryption-standard-aes">Advanced Encryption Standard (AES)</h2>

<p>AES is the most-used cipher in the world, which was standardised by NIST in 2000 as a replacement for DES, and ever since it has become the world's de facto encryption standard. AES processes blocks of 128 bits using a secret key of 128, 192 or 256 bits, with the most common being the 128-bit key as it makes encryption slightly faster and the difference between a 128- and 256-bit security is redundant for most applications.</p>

<p><figure><img src="/docs/figures/aes-array.png" alt="AES Array"></figure></p>

<p>Unlike other ciphers that work with individual bits or 64-bit words, AES views a 16-byte plaintext as a two-dimensional array of bytes <span  class="math">\((s = s_0, s_1, \dots, s_{15})\)</span>, known as the internal state, or just state. AES transforms the bytes, columns, and rows of this array to produce the ciphertext. In order to transform its state, AES uses a substitution-permutation network structure, with 10 rounds for 128-bit keys, 12 for 192-bit keys, and 14 for 256-bit keys.</p>

<p>Here is the pseudocode for encryption in AES-128:</p>
<pre><code>begin aes-encryption(S, K)
  AddRoundKey(S, K[0])
	
  for i in range(1, 9)
    SubBytes(S)
    ShiftRows(S)
    MixColumns(S)
    AddRoundKey(S, K[i])
		
  SubBytes(S)
  ShiftRows(S)
  AddRoundKey(S, K[i])
end</code></pre>
<hr>

<h3 id="aes-overview">AES Overview</h3>

<p><figure><img src="/docs/figures/aes-internals.png" alt="AES Internals"></figure></p>

<ul>
<li><strong>AddRoundKey</strong>: an XOR operation of the current block with the round key</li>
<li><strong>SubBytes</strong>: performs a byte-by-byte substitution on <span  class="math">\((s_0, s_1, \dots, s_{15})\)</span> with another byte according to an S-box, which in AES, is a lookup table of 256 elements</li>
<li><strong>ShiftRows</strong>: shifts the <span  class="math">\(i\)</span>th row of <span  class="math">\(i\)</span> positions, for <span  class="math">\(i \in [0, 3]\)</span></li>
<li><strong>MixColumns</strong>: applies the same linear transformation to each of the four columns of the state
\end{itemize}</li>
</ul>

<p>Each of these operations contributes to AES's security in their own way:</p>

<ul>
<li>Without <code>KeyExpansion</code>, all the rounds would use the same key, <span  class="math">\(K\)</span>, and AES would be vulnerable to slide attacks</li>
<li>Without <code>AddRoundKey</code>, encryption would not depend on the key; hence anyone could decrypt the ciphertext without a key</li>
<li>Without <code>SubBytes</code>, AES would be a large system of linear equations that can be solved using elementary algebra. Hence <code>SubBytes</code> brings nonlinear operations, which adds cryptographic strength</li>
<li>Without <code>ShiftRows</code>, changes in a given column would never affect the other columns. However, this is a desirable property; namely, <em>the avalanche effect</em> - a change in one bit of the input should affect all the output bits</li>
<li>Without <code>MixColumns</code>, changes in a byte would not affect any other bytes of the state. A chosen-plaintext attacker could then decrypt any ciphertext after storing 16 lookup tables of 256 bytes each that hold the encrypted values of each possible value of a byte</li>
</ul>

<p>Recall that AES is a substitution-permutation network (SPN). Here, the substitution layer is <code>SubBytes</code>, and the permutation layer is a combination of <code>ShiftRows</code> and <code>MixColumns</code>.</p>

<hr>

<h3 id="addroundkey">AddRoundKey</h3>

<p>The <code>AddRoundKey</code> transformation is a bitwise operation on the state and the round key. The operation is viewed as a column-wise operation between the 4 bytes of a state column and one word (4 bytes) of the round key so that it can be viewed as a byte-level operation. Note that the inverse transformation, <code>InvAddRoundKey</code> is the same as <code>AddRoundKey</code> because the XOR operation is its own inverse.</p>

<p><figure><img src="/docs/figures/aes-add-round-key.png" alt="AES AddRoundKey"></figure></p>

<hr>

<h3 id="subbytes">SubBytes</h3>

<p>The <code>SubBytes</code> transformation maps bytes into a new byte using a simple lookup table. AES defines a <span  class="math">\(16 \times 16\)</span> matrix of byte values, called an S-box, that consists of a permutation of all possible 256 8-bit values.</p>

<p>Each byte is mapped into a new byte in the following way: the leftmost 4 bits of the byte are used as a row value, and the rightmost 4 bits are used as a column value. These row and column values unique determine an entry in the S-box and the byte is mapped to this entry.</p>

<p><figure><img src="/docs/figures/aes-sub-bytes.png" alt="AES SubBytes"></figure></p>

<p>For example, the hexadecimal value <span  class="math">\(95\)</span> references row 9, column 5 of the S-box, which say, contains the value <span  class="math">\(2A\)</span>. Accordingly, the value <span  class="math">\(95\)</span> is mapped into the value <span  class="math">\(2A\)</span>.</p>

<p>The inverse of this operation, <code>InvSubBytes</code> makes use of the inverse S-box, which is essentially the reverse mapping. For example, if the S-box outputs <span  class="math">\(2A\)</span> for <span  class="math">\(95\)</span>, then the inverse S-box outputs <span  class="math">\(95\)</span> for <span  class="math">\(2A\)</span>.</p>

<hr>

<h3 id="shiftrows">ShiftRows</h3>

<p>The <code>ShiftRows</code> operation works by performing an <span  class="math">\(i\)</span>-byte circular left shift on the <span  class="math">\(i\)</span>-th row, with <span  class="math">\(i = 0\)</span> for the first row. In other words, the first row is untouched, a 1-byte circular left shift is performed to the second row, a 2-byte circular left shift is performed on the third row, and a 3-byte circular left shift is performed on the bottom row.</p>

<p><figure><img src="/docs/figures/aes-shift-rows.png" alt="AES ShiftRows"></figure></p>

<p>The inverse of this transformation, <code>InvShiftRows</code> performs the circular shifts in the opposite direction for the last three rows, with a 1-byte circular right shift for the second row, and so on.</p>

<hr>

<h3 id="mixcolumns">MixColumns</h3>

<p>The <code>MixColumns</code> transformation operates on each column individually. Each byte of a column is mapped into a new value that is a function of all four bytes of that column. The transformation can be defined by the following matrix multiplication on the state:</p>

<p><span  class="math">\[
\begin{bmatrix}
  02 & 03 & 01 & 01\\ 
  01 & 02 & 03 & 01\\
  01 & 01 & 02 & 03\\
  03 & 01 & 01 & 02
\end{bmatrix}
\begin{bmatrix}
  s_{0,0} & s_{0,1} & s_{0,2} & s_{0,3}\\ 
  s_{1,0} & s_{1,1} & s_{1,2} & s_{1,3}\\
  s_{2,0} & s_{2,1} & s_{2,2} & s_{2,3}\\
  s_{3,0} & s_{3,1} & s_{3,2} & s_{3,3}
\end{bmatrix}=
\begin{bmatrix}
  s_{0,0}^{'} & s_{0,1}^{'} & s_{0,2}^{'} & s_{0,3}^{'}\\ 
  s_{1,0}^{'} & s_{1,1}^{'} & s_{1,2}^{'} & s_{1,3}^{'}\\
  s_{2,0}^{'} & s_{2,1}^{'} & s_{2,2}^{'} & s_{2,3}^{'}\\
  s_{3,0}^{'} & s_{3,1}^{'} & s_{3,2}^{'} & s_{3,3}^{'}
\end{bmatrix}
\]</span></p>

<p>The individual additions and multiplications are are performed over the finite field <span  class="math">\(GL(2^8)\)</span>. The <code>MixColumns</code> transformations on a single column can be expressed as:</p>

<p><span  class="math">\[
\begin{aligned}
s_{0, j}^{'} & = (2 \cdot s_{0, j}) \oplus (3 \cdot s_{1, j}) \oplus s_{2, j} \oplus s_{3, j}\\
s_{1, j}^{'} & = s_{0, j} \oplus (2 \cdot s_{1, j}) \oplus (3 \cdot s_{2, j}) \oplus s_{3, j}\\
s_{2, j}^{'} & = s_{0, j} \oplus s_{1, j} \oplus (2 \cdot s_{2, j}) \oplus (3 \cdot s_{3, j})\\
s_{3, j}^{'} & = (3 \cdot s_{0, j}) \oplus s_{1, j} \oplus s_{2, j} \oplus (2 \cdot s_{3, j})
\end{aligned}
\]</span></p>

<p>It follows that the inverse of this transformation would be multiplication by the inverse of the matrix. In symbols:</p>

<p><span  class="math">\[
\begin{bmatrix}
  0E & 0B & 0D & 09\\ 
  09 & 0E & 0B & 0D\\
  0D & 09 & 0E & 0B\\
  0B & 0D & 09 & 0E
\end{bmatrix}
\begin{bmatrix}
  s_{0,0} & s_{0,1} & s_{0,2} & s_{0,3}\\ 
  s_{1,0} & s_{1,1} & s_{1,2} & s_{1,3}\\
  s_{2,0} & s_{2,1} & s_{2,2} & s_{2,3}\\
  s_{3,0} & s_{3,1} & s_{3,2} & s_{3,3}
\end{bmatrix}=
\begin{bmatrix}
  s_{0,0}^{'} & s_{0,1}^{'} & s_{0,2}^{'} & s_{0,3}^{'}\\ 
  s_{1,0}^{'} & s_{1,1}^{'} & s_{1,2}^{'} & s_{1,3}^{'}\\
  s_{2,0}^{'} & s_{2,1}^{'} & s_{2,2}^{'} & s_{2,3}^{'}\\
  s_{3,0}^{'} & s_{3,1}^{'} & s_{3,2}^{'} & s_{3,3}^{'}
\end{bmatrix}
\]</span></p>

<hr>

<h3 id="key-schedule">Key Schedule</h3>

<p>The AES key schedule algorithm is <code>KeyExpansion</code>. This function creates 11 round keys <span  class="math">\((K_0, K_1, \dots, K_{10})\)</span> of 16 bytes each from the 16-byte key, using the same S-box as <code>SubBytes</code> and a combination of XORs.</p>

<p>If an attacker knows any round key, <span  class="math">\(K_i\)</span>, they can determine all of the other round keys, as well as the main key, <span  class="math">\(K\)</span>, by reversing the algorithm. The ability to get the key from any round key is usually seen as an imperfect defence against side-channel attacks, where an attacker may easily recover a round key.</p>

<hr>

<h3 id="decrypting-aes">Decrypting AES</h3>

<p>To decrypt a ciphertext, AES unwinds each operation by taking its inverse function; the inverse lookup table of <code>SubBytes</code> reverses the <code>SubBytes</code> transformation, <code>ShiftRow</code> shifts in the opposite direction, <code>MixColumn</code>'s inverse is applied (as the matrix inverse), and the <code>AddRoundKey</code>'s inverse is itself as the inverse of an XOR is another XOR.</p>

<p>As shown in the figure below, the sequence of transformation for decryption differs from that for encryption. This has the disadvantage that two separate software modules are needed for applications that required both encryption and decryption. However, we can construct an equivalent version of decryption that has the same sequence of transformations as the encryption, with transformations replaced by their inverse. In order to achieve this equivalence, a change in key schedule is required.</p>

<p><figure><img src="/docs/figures/aes-encryption-vs-decryption.png" alt="AES Encryption vs Decryption"></figure></p>

<p>By comparing the encryption and decryption rounds, we see that in order to bring the decryption structure in line with the encryption structure, we need to make two changes. The first two stages of the decryption round need to be interchanged, and the second two stages of the decryption round need to be interchanged, that is, <code>InvMixColumns</code> needs to be interchanged with <code>AddRoundKey</code>, and <code>InvSubBytes</code> needs to be interchanged with <code>InvShiftRows</code>.</p>

<p><figure><img src="/docs/figures/aes-decryption.png" alt="AES Decryption"></figure></p>

<h4 id="interchanging-invshiftrows-and-invsubbytes">Interchanging InvShiftRows and InvSubBytes</h4>

<p><code>InvShiftRows</code> shifts the bytes in the opposite direction (as <code>ShiftRows</code>) but does not alter the byte contents and is independent of the byte contents. Conversely, <code>InvShiftRows</code> alters the contents of the bytes but does not alter the sequence of the bytes and is independent of the sequence of the bytes. Therefore, these two operations commute and can be interchanged.
For a given state <span  class="math">\(S_i = (s_{i, 1}, s_{i, 2}, \dots, s_{i ,16})\)</span>:</p>

<p><span  class="math">\[\text{InvShiftRows[InvSubBytes(}S_i\text{)]}=\text{InvSubBytes[InvShiftRows(}S_i)]\]</span></p>

<h4 id="interchanging-addroundkey-and-invmixcolumns">Interchanging AddRoundKey and InvMixColumns</h4>

<p>Neither of <code>AddRoundKey</code> and <code>InvMixColumns</code> alters the sequence of bytes. If we view the key as a sequence of words, then both <code>AddRoundKey</code> and <code>InvMixColumns</code> operate on the state one column at a time. These two operations are linear with respect to the columns of the input. That is, for a given state <span  class="math">\(S_i = (s_{i, 1}, s_{i, 2}, \dots, s_{i ,16})\)</span> and round key <span  class="math">\(w_j\)</span>:</p>

<p><span  class="math">\[\text{InvMixColumns(}S_i \oplus w_j\text{)}=\text{[InvMixColumns(}S_j\text{)]} \oplus \text{[InvMixColumns(}w_j\text{)]}\]</span></p>

<p>To see this, suppose that the first column of the state is the sequence <span  class="math">\((y_0, y_1, y_2, y_3)\)</span> and the first column of the round key <span  class="math">\(w_j\)</span> is <span  class="math">\((k_0, k_1, k_2, k_3)\)</span>, then we need to show</p>

<p><span  class="math">\[
\begin{bmatrix}
  0E & 0B & 0D & 09\\ 
  09 & 0E & 0B & 0D\\
  0D & 09 & 0E & 0B\\
  0B & 0D & 09 & 0E
\end{bmatrix}
\begin{bmatrix}
  y_0 \oplus k_0\\ 
  y_1 \oplus k_1\\
  y_2 \oplus k_2\\
  y_3 \oplus k_3
\end{bmatrix}=
\begin{bmatrix}
  0E & 0B & 0D & 09\\ 
  09 & 0E & 0B & 0D\\
  0D & 09 & 0E & 0B\\
  0B & 0D & 09 & 0E
\end{bmatrix}
\begin{bmatrix}
  y_0\\ 
  y_1\\
  y_2\\
  y_3
\end{bmatrix}\oplus
\begin{bmatrix}
  0E & 0B & 0D & 09\\ 
  09 & 0E & 0B & 0D\\
  0D & 09 & 0E & 0B\\
  0B & 0D & 09 & 0E
\end{bmatrix}
\begin{bmatrix}
  k_0\\ 
  k_1\\
  k_2\\
  k_3
\end{bmatrix}
\]</span></p>

<p>We will demonstrate that for the first column entry. We need to show that</p>

<p><span  class="math">\[[0E \cdot (y_0 \oplus k_0)] \oplus [0B \cdot (y_1 \oplus k_1)] \oplus [0D \cdot (y_2 \oplus k_2)] \oplus [09 \cdot (y_3 \oplus k_3)]\]</span></p>

<p>is equivalent to</p>

<p><span  class="math">\[[0E \cdot y_0] \oplus [0B \cdot y_1] \oplus [0D \cdot y_2] \oplus [09 \cdot y_3] \oplus [0E \cdot k_0] \oplus [0B \cdot k_1] \oplus [0D \cdot k_2] \oplus [09 \cdot k_3]\]</span></p>

<p>We can see that this equivalence holds by inspection. Therefore, we can interchange <code>AddRoundKey</code> and <code>InvMixColumns</code>, given that we first apply <code>InvMixColumns</code> to the round key. Note that <code>InvMixColumns</code> is not applied to the round key for the input for the first <code>AddRoundKey</code> transformation (before round 1) nor the last <code>AddRoundKey</code> transformation (round 10). This is as these two <code>AddRoundKey</code> transformations are not interchanged with <code>InvMixColumns</code> to produce the equivalent decryption algorithm.</p>

<hr>

<h3 id="is-aes-secure">Is AES secure?</h3>

<p>Fundamentally, AES is seen as a secure cipher as all output bits depend on all input bits in a complex and pseudorandom way. This was achieved by carefully choosing each component for a particular reason - <code>MixColumns</code> for its maximal diffusion properties and <code>SubBytes</code> for its optimal non-linearity, for example. However, there is no proof that AES is immune to all possible attacks, as we do not know what all possible attacks are, and it is not always the case that we know how to prove a cipher is secure against a given attack. AES is said to be heuristic secure, as many skilled people have attempted to break AES, and failed to do so.</p>
</article>
<div id="container-ed2c23646475bf3cb681dcf1db6c94fb"></div>

      <div class="book-footer justify-between">
  

  

  
</div>

      
    </div>

    
  



  </main>

  
</body>

</html>
